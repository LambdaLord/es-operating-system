#summary esidl, the IDL compiler
#labels esidl,IDL

= esidl =

== Introduction ==

The IDL compiler, esidl, is a program that generates C++ header files from the interface definitions written in [http://dev.w3.org/2006/webapi/WebIDL/ Web IDL]. 
Web IDL is an interface definition language being developed at W3C and used in the HTML 5 and other specifications published from [http://www.w3.org/ W3C].

== Syntax ==

esidl `[`option`]` filename ...

== Description ==

esidl creates C++ header files (.h) from IDL source files (.idl).

In the IDL files, interface and method descriptions can be written in [http://java.sun.com/j2se/javadoc/ Javadoc] format.
The esidl compiler writes out the Javadoc comments in the IDL files to the C++ header files.

=== Preprocessing ===

In the IDL files, directives such as `#`ifdef, `#`include, etc. can be used (esidl currently calls `cpp` internally).

== Options ==

-I directory
  Adds directory to the IDL file search path.
  Header files are created retaining their hierarchical structure below `directory`.

-fno-exceptions
  Disables exception specifications being generated for `raises`, `getraises`, and `setraises` clauses.

-indent style
  Generates the C++ header files in the specified coding style. Currently `style` can be either `[http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml google]` or `[http://webkit.org/coding/coding-style.html webkit]`. If -indent option is not specified, the [http://code.google.com/p/es-operating-system/wiki/Style ES coding style] is used.

-include file
  Processes `file` as if it is included from the source file.

-isystem directory
  Adds directory to the system IDL file search path.
  Header files and reflection data are created retaining their hierarchical structure below `directory`.

-namespace name
  Ignores module names in the IDL files and all the definitions are grouped in a single namespace given by `name`.

-object name
  If the defined interface does not extend any interface, `esidl` implicitly assumes the defined interface is derived from the interface specified by `name`. The default name is `Object`.

-template
  Generates a C++ header file for each IDL file that can be used for a bridge implementation between the C++ module and the Web browser like NPAPI bridge for Web IDL.

-skeleton
  Generates a C++ header file for each IDL interface that can be used as a skeleton for the interface implementation.

-string name
  Specifies the C++ class name that maps Web IDL's DOMString. The default is `char*`.

== C++ mapping ==

The mapping from IDL source files (.idl) to C++ header files (.h) is as follows:

=== Modules ===

Modules create a C++ [Namespace namespace].

==== ES IDL ====
{{{
module es
{
};
}}}
==== C++ header file ====
{{{
namespace es
{
}
}}}

=== Interface ===

The interface creates a C++ abstract class. A static class method to retrieve the qualified name of the interface, which is a globally unique interface ID, is automatically generated by esidl.

==== ES IDL ====
{{{
module es
{
  interface Stream
  {
  };
}
}}}
==== C++ header file ====
{{{
namespace es
{
  class Stream
  {
  public:
    static const char* iid()
    {
      return "::es::Stream";
    }
  };
}

}}}

=== Primitive types ===

Primitive types are handled as follows:

|| ES IDL || C++ header file || Comments ||
|| octet || unsigned char ||
|| char || char ||
|| wchar || wchar_t ||
|| string || char`*` ||
|| wstring || wchar_t`*` ||
|| short || short ||
|| long || int || 4 bytes ||
|| long long || long long || 8 bytes ||
|| boolean || bool ||
|| float || float ||
|| double || double ||
|| long double || long double ||

=== Parameter attributes ===

Parameter attributes specify the use of arguments:
`in` is for input only, `out` is for output only, and `inout` is for both input and output.

*Note*: To define functions that can be called by the ECMAScript interpreter, only `in` must be used as parameter attributes. 

*Note*: Both `out` and `inout` attributes are deprecated in Web IDL.

==== ES IDL ====

{{{
void getPosition(out long x, out long y);
void setPosition(in long x, in long y);
}}}
==== C++ header file ====
{{{
virtual void getPosition(int* x, int* y) = 0;
virtual void setPosition(int x, int y) = 0;
}}}

=== Interface names ===

An interface name used as a method argument or return value will be treated as an interface pointer in the header file.

==== ES IDL ====
{{{
void mount(in Stream disk);
Cache create(in Stream backingStore);
}}}
==== C++ header file ====
{{{
virtual void mount(es::Stream* disk) = 0;
virtual es::Cache* create(es::Stream* backingStore) = 0;
}}}

=== Arrays ===

An array is a data type where the number of elements is predetermined.
An array must be defined as a type using `typedef`.

==== ES IDL ====
{{{
typedef octet Mac[6];
long addMulticastAddress(in Mac mac);
}}}
====  C++ header file ====
{{{
typedef unsigned char Mac[6];
virtual int addMulticastAddress(const Mac mac) = 0;
}}}

=== Sequences ===

A sequence is a data structure where the number of elements are specified at runtime.
Like arrays, a sequence must be defined as a type using `typedef`.
In the header files, an argument specifying the length of the sequence is added automatically.

==== ES IDL ====
{{{
typedef sequence<unsigned short> Name;
Name getName();
long setName(in Name name);
}}}
==== C++ header file ====
{{{
typedef unsigned short* Name;
virtual int getName(Name name, int nameLength) = 0;
virtual int setName(const Name name, int nameLength) = 0;
}}}

=== Octet sequences ===

sequence<octet> is converted to void`*` and not unsigned char`*` in the header file.

==== ES IDL ====
{{{
interface Stream
{
    typedef sequence<octet> Buf;
    Buf read();
    long write(in Buf src);
};
}}}
==== C++ header file ====
{{{
class IStream
{
public:
    virtual int read(void* buf, int bufLength) = 0;
    virtual int write(const void* src, int srcLength) = 0;
};
}}}

=== any ===

`any` is converted to `Any`.

==== ES IDL ====
{{{
attribute any strokeStyle;
}}}
==== C++ header file ====
{{{
virtual Any getStrokeStyle(void* strokeStyle, int strokeStyleLength) = 0;
virtual void setStrokeStyle(const Any strokeStyle) = 0;
}}}

=== Object ===

`Object` is converted to void`*` and is implicitly assumed that the pointer is an interface pointer.

=== Attributes ===

When attributes are defined in IDL, setter and getter methods are generated automatically
(only getter is created for readonly attributes). 

==== ES IDL ====
{{{
readonly attribute double X;
attribute double Y;
}}}
==== C++ header file ====
{{{
virtual double getX() = 0;
virtual double getY() = 0;
virtual void setY(double Y) = 0;
}}}

=== Constants ===

Constants are defined using `const` (enum is grammatically correct but is not used in ES).
Upper case is used for TRUE and FALSE in IDL.

==== ES IDL ====
{{{
const long Stream = 1;
const long ReadOnly = 0x01;
}}}
==== C++ header file ====
{{{
static const int Stream = 1;
static const int ReadOnly = 0x01;
}}}

=== exception ===

`exception` is converted to `struct` in header files.

==== ES IDL ====
{{{
exception E
{
    long code;
};
}}}
==== C++ header file ====
{{{
struct E
{
    int code;
};
}}}

=== struct ===

`struct` is kept as `struct` in the header file.

==== ES IDL ====
{{{
struct Geometry
{
    unsigned long heads;
    unsigned long cylinders;
    unsigned long sectorsPerTrack;
    unsigned long bytesPerSector;
    long long diskSize;
};
}}}
==== C++ header file ====
{{{
struct Geometry
{
    unsigned int heads;
    unsigned int cylinders;
    unsigned int sectorsPerTrack;
    unsigned int bytesPerSector;
    long long diskSize;
};
}}}

*Note*: `struct` is not supported in the ECMAScript interpreter, esjs, in the current ES implementation. We plan to remove this limitation in future versions.


=== native ===

`native void_pointer` is converted to `void*`.

==== ES IDL ====
{{{
native void_pointer;

void exit(in void_pointer val);
}}}
==== C++ header file ====
{{{
virtual void exit(void* val); = 0;
}}}