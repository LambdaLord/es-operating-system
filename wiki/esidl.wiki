#summary esidl, the IDL compiler
#labels esidl,IDL,compiler

= esidl =

== Introduction ==

The IDL compiler, esidl, is a program that creates C++ header files and interface reflection data that is needed for implementing interfaces defined in IDL. In esidl, the syntax is that of [http://www.omg.org/gettingstarted/omg_idl.htm OMG IDL] which is also recommended by the [http://www.w3.org/ W3C].

*N.B.*: esidl uses OMG IDL syntax but things like C++ mappings are done simply in a way unique to ES. Apart from the IDL syntax, there is no relation to CORBA.

*N.B.*: In ES 0.0.x versions the IDL syntax was based on DCE but since versions 0.1.x of ES, esidl is not able to process DCE-based syntax.

== Syntax ==

esidl `[`option`]` filename ...

== Documentation ==

esidl creates C++ header files (.h) and binary format reflection data (.ent) from IDL source files (.idl). Like other IDL compilers, esidl does not create stub code for interface method calls. This is because in many argument marshalling processes the ES operating system's kernel automatically returns reflection data.

Also, esidl can write interface and method descriptions in [http://java.sun.com/j2se/javadoc/ Javadoc] format in IDL files. The esidl compiler writes out the Javadoc comments in the IDL files to the C++ header files.

=== Preprocessing ===

.idl files can use directives such as `#`ifdef, `#`include, etc. (esidl currently calls Cpp internally).

==== ES IDL ====
{{{
#ifndef GOOGLE_ES_BASE_IFILE_IDL_INCLUDED
#define GOOGLE_ES_BASE_IFILE_IDL_INCLUDED

#include "es/base/IStream.idl"

module es
{
};

#endif // GOOGLE_ES_BASE_IFILE_IDL_INCLUDED
}}}

== Option ==

-l directory:: Adds directory to the header file search path. Header files and reflection data are created retaining their hierarchical structure below directory.

== C++ mapping ==

The mapping from IDL source files (.idl) to C++ header files (.h) is as follows:

=== Modules ===

Modules create a C++ namespace.

==== ES IDL ====
{{{
module es
{
};
}}}
==== C++ header file ====
{{{
namespace es
{
};
}}}

=== Interface ===

The interface creates a C++ abstract class.

==== ES IDL ====
{{{
interface Foo
{
};
}}}
==== C++ header file ====
{{{
class IFoo
{
};
}}}

*N.B.*: Since Mar. 30, 2008, esidl automatically adds the "I" prefix to each interface class name in the generated C++ header files.

=== Interface ID ===

In ES interface definitions, interface IDs must be specified in DCE's UUID format (at least for the time being).

==== ES IDL ====
{{{
interface Stream
{
    #pragma ID Stream = "DCE:032c16c8-25db-11db-9c02-0009bf000001";
};
}}}
==== C++ header file ====
{{{
class IStream
{
public:
    static const Guid& iid()
    {
        static const Guid iid =
        {
            0x032c16c8, 0x25db, 0x11db, { 0x9c, 0x02, 0x00, 0x09, 0xbf, 0x00, 0x00, 0x01 }
        };
        return iid;
    }
};
}}}

=== Primitive types ===

IDL and C++ primitive types are handled as follows:

|| ES IDL || C++ header file || Comments ||
|| octet || unsigned char ||
|| char || char ||
|| wchar || wchar_t ||
|| string || char`*` ||
|| wstring || wchar_t`*` ||
|| short || short ||
|| long || int || 4 bytes ||
|| long long || long long || 8 bytes ||
|| boolean || bool ||
|| float || float ||
|| double || double ||
|| long double || long double ||
|| uuid || Guid || Extending ES's capabilities ||

=== Parameter attributes ===

We'll now explain the use of arguments. in is for input only, out is for output only and inout is used for both input and output.

*N.B.*: To define functions that can be called by the ECMAScript interpreter, in must be specified in the parameter attributes.

==== ES IDL ====
{{{
void getPosition(out long x, out long y);
void setPosition(in long x, in long y);
}}}
==== C++ header file ====
{{{
virtual void getPosition(int* x, int* y) = 0;
virtual void setPosition(int x, int y) = 0;
}}}

=== Interface names ===

If you specify an interface name as a method argument or return value, it will be treated as an interface pointer in the header file.

==== ES IDL ====
{{{
void mount(in Stream disk);
Cache create(in Stream backingStore);
}}}
==== C++ header file ====
{{{
virtual void mount(IStream* disk) = 0;
virtual ICache* create(IStream* backingStore) = 0;
}}}

=== Arrays ===

An array is a data type where the number of elements is static. The type name is defined in typedef.

==== ES IDL ====
{{{
typedef octet Mac[6];
long addMulticastAddress(in Mac mac);
}}}
====  C++ header file ====
{{{
typedef unsigned char Mac[6];
virtual int addMulticastAddress(const Mac mac) = 0;
}}}

=== Sequences ===

Sequences are data structures where the size specified at runtime can be changed. Like arrays, the type name is defined in typedef. Unlike arrays, arguments specifying the length of a sequence are created automatically.

==== ES IDL ====
{{{
typedef sequence<unsigned short> Name;
Name getName();
long setName(in Name name);
}}}
==== C++ header file ====
{{{
typedef unsigned short* Name;
virtual int getName(Name name, int nameLength) = 0;
virtual int setName(const Name name, int nameLength) = 0;
}}}

=== Object sequences ===

sequence<octet> is changed to void`*` and not unsigned char`*` in the header file.

==== ES IDL ====
{{{
interface Stream
{
    typedef sequence<octet> Buf;
    Buf read();
    long write(in Buf src);
};
}}}
==== C++ header file ====
{{{
class IStream
{
public:
    virtual int read(void* buf, int bufLength) = 0;
    virtual int write(const void* src, int srcLength) = 0;
};
}}}

=== any ===

This is changed to any void`*`.

==== ES IDL ====
{{{
void exit(in any val);
}}}
==== C++ header file ====
{{{
virtual void exit(const void* val) = 0;
}}}

=== Object ===

Objects also create void`*`. However, unlike void`*` created with any, it is implicitly assumed that the interface pointer is indicated.

*N.B.*: With esidl, you can specify an Object's interface ID with a UUID type argument. For the return value, the ID specified as the method's *final* UUID type argument will be the returned Object ID. For arguments, the ID of a UUID type argument appearing just before an Object type argument will be the Object ID.

==== ES IDL ====
{{{
Object queryInterface(in uuid riid);
}}}
==== C++ header file ====
{{{
virtual void* queryInterface(const Guid& riid) = 0;
}}}

=== Attributes ===

When attributes are defined in IDL, setter and getter are created automatically (only getter is created for readonly attributes). Boolean getter attributes are named in the style "is + attribute name".

==== ES IDL ====
{{{
readonly attribute double X;
attribute double Y;
attribute boolean on;
}}}
==== C++ header file ====
{{{
virtual double getX() = 0;
virtual double getY() = 0;
virtual void setY(double Y) = 0;
virtual bool isOn() = 0;
virtual void setOn(bool on) = 0;
}}}

=== Constants ===

Constants are defined using const (enum is syntactically possible but is not used as a rule). Upper case is used for TRUE and FALSE in IDL.

==== ES IDL ====
{{{
const long Stream = 1;
const long ReadOnly = 0x01;
}}}
==== C++ header file ====
{{{
static const int Stream = 1;
static const int ReadOnly = 0x01;
}}}

=== exception ===

Exceptions are changed to struct in header files.

==== ES IDL ====
{{{
exception E
{
    long code;
};
}}}
==== C++ header file ====
{{{
struct E
{
    int code;
};
}}}

=== struct ===

struct is kept as struct in the header file.

==== ES IDL ====
{{{
struct Geometry
{
    unsigned long heads;
    unsigned long cylinders;
    unsigned long sectorsPerTrack;
    unsigned long bytesPerSector;
    long long diskSize;
};
}}}
==== C++ header file ====
{{{
struct Geometry
{
    unsigned int heads;
    unsigned int cylinders;
    unsigned int sectorsPerTrack;
    unsigned int bytesPerSector;
    long long diskSize;
};
}}}

*N.B.*: struct is not supported in the ECMAScript interpreter, esjs, in ES version 0.1.1. We plan to remove this limitation in future versions.