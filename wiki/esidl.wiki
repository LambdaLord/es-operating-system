#summary esidl, the IDL compiler
#labels esidl,IDL

= esidl =

== Introduction ==

The IDL compiler, esidl, is a program that generates C++ header files from the interface definitions written in [http://dev.w3.org/2006/webapi/WebIDL/ Web IDL]. 
Web IDL is an interface definition language being developed at W3C and used in the HTML 5 and other specifications published from [http://www.w3.org/ W3C].

== Syntax ==

esidl `[`option`]` filename ...

== Description ==

esidl creates C++ header files (.h) from IDL source files (.idl).

Note: To expand mixins specified by the `implements` Web IDL statement, related IDL files MUST be processed at once by specifying the every IDL filename in the argument list.

=== Preprocessing ===

In the IDL files, directives such as `#`ifdef, `#`include, etc. can be used (esidl currently calls `cpp` internally).

Note: In the IDL files, interface and method descriptions can be written in [http://java.sun.com/j2se/javadoc/ Javadoc] format, and the esidl compiler copies the Javadoc comments in the IDL files to the C++ header files.

== Options ==

-I directory
  Adds directory to the IDL file search path.
  Header files are created retaining their hierarchical structure below `directory`.

-fno-exceptions
  Disables exception specifications being generated for `raises`, `getraises`, and `setraises` clauses.

-indent style
  Generates the C++ header files in the specified coding style. Currently `style` can be either `[http://google-styleguide.googlecode.com/svn/trunk/cppguide.xml google]` or `[http://webkit.org/coding/coding-style.html webkit]`. If -indent option is not specified, the [http://code.google.com/p/es-operating-system/wiki/Style ES coding style] is used.

-include file
  Processes `file` as if it is included from the source file.

-isystem directory
  Adds directory to the system IDL file search path.
  Header files and reflection data are created retaining their hierarchical structure below `directory`.

-namespace name
  Ignores module names in the IDL files and all the definitions are grouped in a single namespace given by `name`.

-object name
  If the defined interface does not extend any interface, `esidl` implicitly assumes the defined interface is derived from the interface specified by `name`. The default name is `Object`.

-template
  Generates a C++ header file for each IDL file that can be used for a bridge implementation between the C++ module and the Web browser like NPAPI bridge for Web IDL.

-skeleton
  Generates a C++ header file for each IDL interface that can be used as a skeleton for the interface implementation.

-string name
  Specifies the C++ class name that maps Web IDL's DOMString. The default is `char*`.

== C++ mapping ==

The mapping from IDL source files (.idl) to C++ header files (.h) is as follows:

=== Modules ===

Modules create C++ namespaces if `-namespace` option is not used.

==== ES IDL ====
{{{
module dom
{
};
}}}
==== C++ header file ====
{{{
namespace dom
{
}
}}}

If `-namespace` option is used, module names are ignored.

==== ES IDL ====
{{{
module dom
{
};
}}}
==== C++ header file ====
{{{
NA
}}}

=== Interfaces ===

The interface creates a C++ abstract class.

==== ES IDL ====
{{{
interface CanvasRenderingContext2D
{
};
}}}
==== C++ header file ====
{{{
class CanvasRenderingContext2D : public Object 
{
};
}}}

A static class method to retrieve the qualified name of the interface, which is a globally unique interface ID, is automatically generated by esidl.

=== Constants ===

Constants defined in interfaces and exceptions are defined as static class/struct members.

==== ES IDL ====
{{{
interface MediaError 
{
    const unsigned short MEDIA_ERR_ABORTED = 1;
    const unsigned short MEDIA_ERR_NETWORK = 2;
    const unsigned short MEDIA_ERR_DECODE = 3;
    const unsigned short MEDIA_ERR_NONE_SUPPORTED = 4;
};
}}}
==== C++ header file ====
{{{
class MediaError : public Object
{
public:
    static const unsigned short MEDIA_ERR_ABORTED = 1;
    static const unsigned short MEDIA_ERR_NETWORK = 2;
    static const unsigned short MEDIA_ERR_DECODE = 3;
    static const unsigned short MEDIA_ERR_NONE_SUPPORTED = 4;
};
}}}

=== Operations ===

Each operation defined in the IDL interface will be mapped to one or more virtual member functions in the C++ interface class. 

==== ES IDL ====
{{{
interface CanvasRenderingContext2D 
{
    void fillRect(float x, float y, float w, float h);
};
}}}
==== C++ header file ====
{{{
class CanvasRenderingContext2D : public Object
{
    public:
        virtual void fillRect(float x, float y, float w, float h) = 0;
};
}}}

=== Optional ===

If the `optional` keyword appears on an operation argument, it indicates that the operation can be invoked by passing values only for the those arguments appearing before the optional argument in the operation's argument list.

==== ES IDL ====
{{{
interface ColorCreator 
{
    Object createColor(in float v1, optional in float v2, in float v3, optional in float alpha);
};
}}}
==== C++ header file ====
{{{
class ColorCreator 
{
public:
    virtual Object* createColor(float v1) = 0;
    virtual Object* createColor(float v1, float v2, float v3) = 0;
    virtual Object* createColor(float v1, float v2, float v3, float alpha) = 0;
};  
}}}

=== Variadic operation ===

If the final argument uses the `...` terminal, it indicates that the operation is variadic, and can be passed zero or more arguments after the regular arguments.

==== ES IDL ====
{{{
interface IntegerSet
{
    readonly attribute unsigned long cardinality;

    void union(long... ints);
    void intersection(long... ints);
};
}}}
==== C++ header file ====
{{{
class IntegerSet 
{
public:
    virtual uint32_t getCardinality() = 0;
    virtual void union(const int* ints = 0, size_t intsLength = 0) = 0;
    virtual void intersection(const int* ints = 0, size_t intsLength = 0) = 0;
};
}}}

=== Attributes ===

For each attribute defined on the IDL interface, a getter method is declared. For each attribute defined on the IDL interface that is not read only, a corresponding setter method is also declared.

==== ES IDL ====
{{{
interface CanvasRenderingContext2D 
{
    attribute float globalAlpha;
};
}}}
==== C++ header file ====
{{{
class CanvasRenderingContext2D : public Object 
{
public:
    virtual float getGlobalAlpha() = 0;
    virtual void setGlobalAlpha(float globalAlpha) = 0;
};
}}}

=== `[`!PutForwards`]` ===

If the `[PutForwards]` extended attribute appears on a read only attribute, a setter method is declared taking the specified attribute type as an argument.

==== ES IDL ====
{{{
interface Name
{
    attribute DOMString full;
    attribute DOMString family;
    attribute DOMString given;
  };

interface Person 
{
    [PutForwards=full] readonly attribute Name name;
};
}}}
==== C++ header file ====
{{{
class Person 
{
public:
    virtual Name* getName() = 0;
    virtual void setName(const char* name) = 0;  // setName() does not take Name* as an argument.
};
}}}

=== Primitive types ===

Primitive types are handled as follows:

|| ES IDL || C++ header file || Comments ||
|| octet || unsigned char ||
|| char || char ||
|| wchar || wchar_t ||
|| string || char`*` ||
|| wstring || wchar_t`*` ||
|| short || short ||
|| long || int || 4 bytes ||
|| long long || long long || 8 bytes ||
|| boolean || bool ||
|| float || float ||
|| double || double ||
|| long double || long double ||

=== Interface names ===

An interface name used as a method argument or return value will be treated as an interface pointer in the header file.

==== ES IDL ====
{{{
void mount(in Stream disk);
Cache create(in Stream backingStore);
}}}
==== C++ header file ====
{{{
virtual void mount(es::Stream* disk) = 0;
virtual es::Cache* create(es::Stream* backingStore) = 0;
}}}

=== Arrays ===

An array is a data type where the number of elements is predetermined.
An array must be defined as a type using `typedef`.

==== ES IDL ====
{{{
typedef octet Mac[6];
long addMulticastAddress(in Mac mac);
}}}
====  C++ header file ====
{{{
typedef unsigned char Mac[6];
virtual int addMulticastAddress(const Mac mac) = 0;
}}}

=== Sequences ===

A sequence is a data structure where the number of elements are specified at runtime.
Like arrays, a sequence must be defined as a type using `typedef`.
In the header files, an argument specifying the length of the sequence is added automatically.

==== ES IDL ====
{{{
typedef sequence<unsigned short> Name;
Name getName();
long setName(in Name name);
}}}
==== C++ header file ====
{{{
typedef unsigned short* Name;
virtual int getName(Name name, int nameLength) = 0;
virtual int setName(const Name name, int nameLength) = 0;
}}}

=== Octet sequences ===

sequence<octet> is converted to void`*` and not unsigned char`*` in the header file.

==== ES IDL ====
{{{
interface Stream
{
    typedef sequence<octet> Buf;
    Buf read();
    long write(in Buf src);
};
}}}
==== C++ header file ====
{{{
class IStream
{
public:
    virtual int read(void* buf, int bufLength) = 0;
    virtual int write(const void* src, int srcLength) = 0;
};
}}}

=== any ===

`any` is converted to `Any`.

==== ES IDL ====
{{{
attribute any strokeStyle;
}}}
==== C++ header file ====
{{{
virtual Any getStrokeStyle(void* strokeStyle, int strokeStyleLength) = 0;
virtual void setStrokeStyle(const Any strokeStyle) = 0;
}}}

=== Object ===

`Object` is converted to void`*` and is implicitly assumed that the pointer is an interface pointer.

=== Exceptions ===

`exception` is converted to `struct` in header files.

==== ES IDL ====
{{{
exception E
{
    long code;
};
}}}

==== C++ header file ====
{{{
struct E
{
    int code;
};
}}}

=== native ===

`native void_pointer` is converted to `void*`.

==== ES IDL ====
{{{
native void_pointer;

void exit(in void_pointer val);
}}}
==== C++ header file ====
{{{
virtual void exit(void* val); = 0;
}}}