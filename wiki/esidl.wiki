#summary esidl, the IDL compiler
#labels esidl,IDL,compiler

= esidl =

== Introduction ==

The IDL compiler, esidl, is a program that generates C++ header files and interface reflection data files from the interface definitions written in IDL (interface definition language).
In esidl, the syntax is that of [http://www.omg.org/gettingstarted/omg_idl.htm OMG IDL] which is also used in the HTML and other specifications from [http://www.w3.org/ W3C].

*Note*: esidl uses OMG IDL syntax but things like C++ mappings are done simply in a way unique to ES. Apart from the IDL grammar, there is no relation to CORBA.

== Syntax ==

esidl `[`option`]` filename ...

== Description ==

esidl creates C++ header files (.h) and binary format reflection data (.ent) from IDL source files (.idl).
Unlike other IDL compilers, esidl does not generate stub code for procedure calls.
This is because the ES operating system's kernel processes parameter passing, like the marshalling process, at the meta-level using reflection.

In the IDL files, interface and method descriptions can be written in [http://java.sun.com/j2se/javadoc/ Javadoc] format.
The esidl compiler writes out the Javadoc comments in the IDL files to the C++ header files.

=== Preprocessing ===

In the IDL files, directives such as `#`ifdef, `#`include, etc. can be used (esidl currently calls `cpp` internally).

==== ES IDL ====
{{{
#ifndef GOOGLE_ES_BASE_IFILE_IDL_INCLUDED
#define GOOGLE_ES_BASE_IFILE_IDL_INCLUDED

#include "es/base/IStream.idl"

module es
{
};

#endif // GOOGLE_ES_BASE_IFILE_IDL_INCLUDED
}}}

== Option ==

-l directory
  Adds directory to the header file search path.
  Header files and reflection data are created retaining their hierarchical structure below `directory`.

== C++ mapping ==

The mapping from IDL source files (.idl) to C++ header files (.h) is as follows:

=== Modules ===

Modules create a C++ [Namespace namespace].

==== ES IDL ====
{{{
module es
{
};
}}}
==== C++ header file ====
{{{
namespace es
{
};
}}}

=== Interface ===

The interface creates a C++ abstract class.

==== ES IDL ====
{{{
interface Foo
{
};
}}}
==== C++ header file ====
{{{
class IFoo
{
};
}}}

*Note*: Since Mar. 30, 2008, esidl automatically adds the "I" prefix to each interface class name in the generated C++ header files.

=== Interface ID ===

In ES interface definitions, interface IDs must be specified in DCE's UUID format for each interface
(at least for the time being).

==== ES IDL ====
{{{
interface Stream
{
    #pragma ID Stream = "DCE:032c16c8-25db-11db-9c02-0009bf000001";
};
}}}
==== C++ header file ====
{{{
class IStream
{
public:
    static const Guid& iid()
    {
        static const Guid iid =
        {
            0x032c16c8, 0x25db, 0x11db, { 0x9c, 0x02, 0x00, 0x09, 0xbf, 0x00, 0x00, 0x01 }
        };
        return iid;
    }
};
}}}

=== Primitive types ===

Primitive types are handled as follows:

|| ES IDL || C++ header file || Comments ||
|| octet || unsigned char ||
|| char || char ||
|| wchar || wchar_t ||
|| string || char`*` ||
|| wstring || wchar_t`*` ||
|| short || short ||
|| long || int || 4 bytes ||
|| long long || long long || 8 bytes ||
|| boolean || bool ||
|| float || float ||
|| double || double ||
|| long double || long double ||
|| uuid || Guid || Extending ES's capabilities ||

=== Parameter attributes ===

Parameter attributes specify the use of arguments:
`in` is for input only, `out` is for output only, and `inout` is for both input and output.

*Note*: To define functions that can be called by the ECMAScript interpreter, only `in` must be used as parameter attributes.

==== ES IDL ====
{{{
void getPosition(out long x, out long y);
void setPosition(in long x, in long y);
}}}
==== C++ header file ====
{{{
virtual void getPosition(int* x, int* y) = 0;
virtual void setPosition(int x, int y) = 0;
}}}

=== Interface names ===

An interface name used as a method argument or return value will be treated as an interface pointer in the header file.

==== ES IDL ====
{{{
void mount(in Stream disk);
Cache create(in Stream backingStore);
}}}
==== C++ header file ====
{{{
virtual void mount(IStream* disk) = 0;
virtual ICache* create(IStream* backingStore) = 0;
}}}

=== Arrays ===

An array is a data type where the number of elements is predetermined.
An array must be defined as a type using `typedef`.

==== ES IDL ====
{{{
typedef octet Mac[6];
long addMulticastAddress(in Mac mac);
}}}
====  C++ header file ====
{{{
typedef unsigned char Mac[6];
virtual int addMulticastAddress(const Mac mac) = 0;
}}}

=== Sequences ===

A sequence is a data structure where the number of elements are specified at runtime.
Like arrays, a sequence must be defined as a type using `typedef`.
In the header files, an argument specifying the length of the sequence is added automatically.

==== ES IDL ====
{{{
typedef sequence<unsigned short> Name;
Name getName();
long setName(in Name name);
}}}
==== C++ header file ====
{{{
typedef unsigned short* Name;
virtual int getName(Name name, int nameLength) = 0;
virtual int setName(const Name name, int nameLength) = 0;
}}}

=== Octet sequences ===

sequence<octet> is converted to void`*` and not unsigned char`*` in the header file.

==== ES IDL ====
{{{
interface Stream
{
    typedef sequence<octet> Buf;
    Buf read();
    long write(in Buf src);
};
}}}
==== C++ header file ====
{{{
class IStream
{
public:
    virtual int read(void* buf, int bufLength) = 0;
    virtual int write(const void* src, int srcLength) = 0;
};
}}}

=== any ===

`any` is converted to void`*`.

==== ES IDL ====
{{{
void exit(in any val);
}}}
==== C++ header file ====
{{{
virtual void exit(const void* val) = 0;
}}}

=== Object ===

`Object` is converted to void`*`. However, unlike void`*` converted from `any`, it is implicitly assumed that the pointer is an interface pointer.

*Note*: With esidl, you can specify the object's interface ID with a UUID type argument. For the return value, the ID specified as the method's *final* UUID type argument will be the returned object's ID. For arguments, the ID of a UUID type argument appearing just before an Object type argument will be the object's ID.

==== ES IDL ====
{{{
Object queryInterface(in uuid riid);
}}}
==== C++ header file ====
{{{
virtual void* queryInterface(const Guid& riid) = 0;
}}}

=== Attributes ===

When attributes are defined in IDL, setter and getter methods are generated automatically
(only getter is created for readonly attributes). 
A getter for a `boolean` attribute is named in the style "is + attribute name".

==== ES IDL ====
{{{
readonly attribute double X;
attribute double Y;
attribute boolean on;
}}}
==== C++ header file ====
{{{
virtual double getX() = 0;
virtual double getY() = 0;
virtual void setY(double Y) = 0;
virtual bool isOn() = 0;
virtual void setOn(bool on) = 0;
}}}

=== Constants ===

Constants are defined using `const` (enum is grammatically correct but is not used in ES).
Upper case is used for TRUE and FALSE in IDL.

==== ES IDL ====
{{{
const long Stream = 1;
const long ReadOnly = 0x01;
}}}
==== C++ header file ====
{{{
static const int Stream = 1;
static const int ReadOnly = 0x01;
}}}

=== exception ===

`exception` is converted to `struct` in header files.

==== ES IDL ====
{{{
exception E
{
    long code;
};
}}}
==== C++ header file ====
{{{
struct E
{
    int code;
};
}}}

=== struct ===

`struct` is kept as `struct` in the header file.

==== ES IDL ====
{{{
struct Geometry
{
    unsigned long heads;
    unsigned long cylinders;
    unsigned long sectorsPerTrack;
    unsigned long bytesPerSector;
    long long diskSize;
};
}}}
==== C++ header file ====
{{{
struct Geometry
{
    unsigned int heads;
    unsigned int cylinders;
    unsigned int sectorsPerTrack;
    unsigned int bytesPerSector;
    long long diskSize;
};
}}}

*Note*: `struct` is not supported in the ECMAScript interpreter, esjs, in ES version 0.1.1. We plan to remove this limitation in future versions.